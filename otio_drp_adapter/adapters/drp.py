import json
import opentimelineio as otio
from os.path import basename


"""
Adapter to read (and ultimately write) a .drp file generated by the
Blackmagic Design ATEM ISO mixer, aimed at DaVinci's timeline format.

File is JSON-based, line-delimited.
First line includes the metadata and sources in a JSON hash,
Next lines describes the scene switches until the show ends.

Careful: this .drp file format might not be exactly compatible with DaVinci,
as the Blackmagic ATEM ISO may generate a simplified version, and there
doesn't seem to be any easy to find reference specifications for those files.

"""

""" Represent .drp master timecode for simpler usage with otio timeranges"""


class DrpTimecode:
    """Simple constructor, taking a timecode as HH:MM:SS:FF
    and an optional framerate"""

    reference = "00:00:00:00"

    def __init__(self, tc, rate=25):
        hours, minutes, seconds, frames = tc.split(":")
        self.hours = int(hours)
        self.minutes = int(minutes)
        self.seconds = int(seconds)
        self.frames = int(frames)
        self.rate = rate

    """In case we need to output it"""

    def __str__(self):
        return f"{self.hours}:{self.minutes}:{self.seconds}:{self.frames}"

    def asolute_nb_frames(self):
        return (
            self.frames
            + self.rate * self.seconds
            + self.rate * 60 * self.minutes
            + self.rate * 3600 * self.hours
        )

    def nb_frames(self):
        return (
            self.asolute_nb_frames()
            - DrpTimecode(DrpTimecode.reference, self.rate).asolute_nb_frames()
        )

    """Let's offer tc1 - tc2 = number of frames in between"""

    def __sub__(a, b):
        return a.nb_frames() - b.nb_frames()


def read_from_file(filepath):
    # We read the .drp file directly
    with open(filepath) as source:
        # First line contains metadata and the starting settings
        metadata = json.loads(source.readline().strip())

        # Next ones are the scene switches, let's decode them right away
        timeline_data = []
        for line in source:
            timeline_data += [json.loads(line.strip())]
        # We use the filename as the timeline name (without the .drp suffix)
        timeline_name = basename(filepath[:-4])
        track_name = "Main Mix"
        timeline = otio.schema.Timeline(timeline_name)
        # We will use the masterTimecode as a 0 reference
        mt = metadata["masterTimecode"]
        # BlackMagic's ATEM seems to be only 1080p25, but well
        widths, rates = metadata["videoMode"].split("p")
        rate = int(rates)
        # For now, the timeline is a single track.
        track = otio.schema.Track(track_name)
        timeline.tracks.append(track)
        # If we don't have sources, the .drp file is probably broken.
        if "sources" not in metadata:
            raise Exception("No sources in drp file")

        # Start of current clip
        DrpTimecode.reference = mt
        # By definition, this should be 0, maybe we could just set it to 0.
        current_tc = DrpTimecode(mt).nb_frames()
        # Let's compute the duration of the full scene based on the last switch
        last_tc = timeline_data[-1]["masterTimecode"]
        duration = DrpTimecode(last_tc).nb_frames()
        # And make it available for the ext ref
        available_range = otio.opentime.TimeRange(
            start_time=otio.opentime.RationalTime(current_tc, rate),
            duration=otio.opentime.RationalTime(duration, rate),
        )

        # Let's create an hash with all the indices as the key for later
        # and create the external reference for the files
        # (it may be more clever to generate one for each source)
        extrefs = dict()
        for src in metadata["sources"]:
            src["ref"] = None
            # If it's an actual file, generate a ref for it
            if "file" in src:
                ref = otio.schema.ExternalReference(
                    target_url=src["file"], available_range=available_range
                )
                # add it to the src dict from JSON
                src["ref"] = ref
            # add our entry to extrefs, with _index_ as the key (it's an int.)
            extrefs[src["_index_"]] = src

        # Loosely try to get the scene chosen before the show starts
        try:
            current_source = metadata["mixEffectBlocks"][0]["source"]
        except KeyError:
            current_source = 0

        # Let's loop over the switches in the timeline
        for c in timeline_data:
            # End of current clip is there, and it has that many frames
            next_clip_tc = DrpTimecode(c["masterTimecode"], rate)
            next_clip_frames = next_clip_tc.nb_frames()

            # So let's figure out its name and ext ref from our hash
            # and compute its length in frames
            clip = otio.schema.Clip(
                f'{extrefs[current_source]["name"]}',
                media_reference=extrefs[current_source]["ref"],
                source_range=otio.opentime.TimeRange(
                    otio.opentime.RationalTime(current_tc, rate),
                    otio.opentime.RationalTime(next_clip_frames, rate),
                ),
            )
            # Add it to the track
            track.append(clip)
            # Prepare for the next round, let's move on at the end
            # of the added clip, and set the sources for the next clip.
            current_tc += next_clip_frames
            if "source" in c["mixEffectBlocks"][0]:
                current_source = c["mixEffectBlocks"][0]["source"]
            else:
                break

    return timeline
